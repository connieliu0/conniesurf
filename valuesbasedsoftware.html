<!DOCTYPE html>
<html lang="en">
  <link rel="stylesheet" href="./global.css" type="text/css" />
  <link rel="stylesheet" href="./styles.css" type="text/css" />
  <script src="./cursor.js" defer></script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Software with a Point of View - Chinatown.js talk August 14 2025</title>
  </head>
  <body>
    <div class="background-layer" id="background-layer"></div>
    <div class="blob"></div>
    <div class="col">

  
      <div class="line">
        <div class="slide-container">
          <div class="slide-content">
            <a href="index.html" class="back-link"><p>‚Üê back to connie.surf</p></a>
            <!-- 
              To use custom colors when there's no image, add:
              data-bg-color="rgb(255, 200, 100)" (or any CSS color value)
              data-text-color="rgb(50, 50, 50)" (or any CSS color value)
              
              To use a blurred image in the background (separate from the slide image), add:
              data-bg-image="./path/to/image.png"
              
              Examples:
              <div class="slide-section" data-bg-color="#ff6b6b" data-text-color="#ffffff">
              <div class="slide-section" data-image="./slide.png" data-bg-image="./blurred-bg.png">
            -->
            <div class="slide-section" data-image="./image/slides/panning.gif" data-bg-image="./image/slides/newonboarding.png">
              <h3>Software with a Point of View</h3>
              <p style="color: rgb(132, 137, 141);"><em>Chinatown.js talk, August 14 2025</em></p>
            </br>
          </br>
              <p>PART 1: THE CONCEPT BEHIND LINK DUMP</p>
        </br>
              <p>The beginning of this talk is about <a href="https://linkdump.connie.surf" target="_blank">Link Dump</a>, which is an ephemeral link canvas I made where the links are designed to eventually disappear and remain only as an exportable csv.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/slide2.png" data-bg-image="./image/slides/newonboarding.png">
              <p>While I was creating this project I went against the normal design process that I follow during my day job as a product designer. I ended up ultimately designing for myself. More specifically, I designed for the values I believe in. </p>
              </br>
              <p>The first being the urgency to finish creative work and the second as a manifestation of feelings I had about data on the internet.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/slide3.png">
              <p>The urgency was because I would take notoriously long to finish creative projects. As a serial digital hoarder writer, I used to save so much. I would save screenshots, notes, photos and links with the intent of synthesizing and creating... but in the end it would remain an ever running to-do list. </p>
                </br>
                <p>At the same time I had read the <em>The Creative Act</em>, where Rick Rubin quotes creativity as a universal force where if you don't act upon it, it would eventually disappear.</p>
            </div>
            <div class="slide-section" data-image="./image/slides/idle.gif">
              <p>In essence, that sparked the first iteration of Link Dump. You could paste or import links as cards on the canvas and set a time limit for when you wanted to finish your project. The cards would age with time and when the time limit passed the canvas would erase itself. The passage of time also manifested as a screensaver that would appear if you left your tab idle for too long.</p>
            </div>
              <div class="slide-section" data-image="./image/slides/cloud.png">
              <p>The second part was I wanted to create lighter software. The temporal aspect was important because I had a personal belief that the internet remembered too much.</p>
                </br>
                <p>When we think of cloud storage we think it as a weightless entity. However, the internet has an immense physicality to it from data centers in the midwest to huge cables under the ocean. As the internet becomes more integral to our lives, our physical presence only grows.</p>
                </br>
                <p>Furthermore, data is actually a huge monetization lever, and companies don't have an incentive to make it easy to mass delete items. The easier solution is just to subscribe and upgrade to unlimited cloud storage and continue to accumulate.</p>
              </div>
              <div class="slide-section" data-image="./image/slides/save.png">
                <p>In my first iteration of this, you can do everything locally. Data would be locally stored in the browser and you could eventually export it to your own hard drive when the time was up.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/tiktok.png">
              <p>Allowing the user to own their data was important to me because we don't realize that our data is owned by large corporations that can disappear at any second. Earlier in 2025, Tiktok was banned and they let you export your data as a huge CSV, but you couldn't actually save your Tiktoks because the CSV linked out to the Tiktok site as well.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/tumblr.png">
              <p style="color: rgb(206, 171, 98)" data-preserve-color="true">But beyond the technicalities of it all, as a whole my motivations can be summarized from this one picture I saw on tumblr when I was 16.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/putitdown.png">
              <p>We hold on and notice and collect, but we never really put it down. Putting it down is how you process and create and engage with the world around you. It's how you ultimately remember.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/process.png" data-bg-image="./image/slides/process.png">
              <p>PART 2: THE PROCESS OF MAKING LINK DUMP</p>
              <p>Beyond the end result, the process was equally as important. I created the bulk of this project between the months of March to May. I'm a designer who before this, only knew HTML, CSS and Javascript. I knew how components worked in React but I never did state management before or connected to a database.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.png" data-image="./image/slides/output.gif">
              <p>As I've mentioned before the typical design process success would be I'd explore a prototype and test on Figma and build in increments. But what I actually did was a linear process where I built out what I thought was the MVP and then kept on redoing it. The first version was just a draggable card canvas with a timer.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/demo.png">
              <p style="color:white">After that I wanted to demo it at an art event and have a participatory aspect where people contribute their links onto a group collaborative board. I then introduced a board that anyone could access via a link and had cross-device syncing and collaboration. People could upload an image from their phone and it would show up in the browser window.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.png" data-image="./image/slides/modal.gif">
              <p>Then I decided it would be a good idea to show my app to some people and ask them if they would use it. At this point, a particular feature I was proud of was this glossy modal that smoothly transitioned from the onboarding directions to the board creation screen. When I tested it some friends told me that there was too much text and inputs in the modal and they weren't going to read it.That was when I realized I needed a new onboarding mode.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/fullonboarding.png">
              <p>I recoded it again and now on your first time viewing Link Dump, it immediately opens to a canvas that has some cards explaining what's going on. I also simplified the board creation modal to have more defaults so you don't really have to fill out much to get started and it begins.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/overload.png">
              <p>After showing it to some people, I decided it was time to use it myself to write an essay. I had been writing an essay about the underpinnings of this project, which I called the "Organic web". After importing and organizing the links from my <a href="https://www.are.na/connie-liu-kg4ypfp7ry0/organic-web" target="_blank">are.na board</a> I realized that I had put the links into groups. Unfortunately the CSV export did not remember these groups I had created and I couldn't label them. At this point I thought if I could just build out grouping, then I could finally be done with this project.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/road.webp">
              <p>It was also around this point I did not understand some parts of my code base anymore. Because I was using AI to assist some of the more fullstack programming, I started to break my code a lot with the further changes I made. At this point I started to feel really frustrated, I had spent hundreds of hours creating slightly buggy software and I couldn't figure out how to add the final feature to allow myself to actually use it.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/road.webp">
              <p>So what was the reason to keep doing this?</p>
              </br>
              <p> I'm a product designer and after a certain point you start to realize that essentially you will always be designing for a business, and a business it has to make money. A lot of things you design end up as monetization levers. When it occurs to an extreme, it's called enshittification.</p>
            </br> <p> Enshittification describes how companies first offer high quality services but then because they are backed by venture capital, they have to implement some decisions at cost for the user to maximize profits and exhibit growth.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/road.webp">
              <p>I started to wonder, is there even a way to make software that is "good"? What is good anyways? If you go to the silicon valley startup scene, "good" would be "what is a niche saas market where I can follow basic design principles to make it easy do the main task and also use AI".</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.png" data-image="./image/slides/article.png">
              <p>To me, I think of "good" software as a vector for reimagining. </p> </br> <p>
                I recently read <a href="https://harpers.org/archive/2025/06/the-reenchanted-world-karl-ove-knausgaard-digital-age/" target="_blank">this article</a> in which two authors are discussing the state of the world. One of the authors, James, wrote this book in which he writes about all the data surveillance and bad things tech is doing. He comes to this conclusion that we are screwed because the current system we live in keeps the existing power dynamics and there's no interest in educating on how it works. After he writes the first book, he becomes quite depressed and the only way out of it is by making things (he makes several solar powered objects in the article). The conclusion he comes to is that when you make your own technology, you can make something different and upset the existing power balance. Making is something that people are doing all the time and that you can do yourself.
              </p></br> <p> That leads me to my answer which is values based software.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.png" data-image="./image/slides/software.png">
              <p>PART 3: VALUES BASED SOFTWARE</p>
            </br>
              <p>I'll explain this concept through an anecdote. There are so many websites where you save and categorize. There is Pinterest, and Cosmos, and Silk and River and if you're listening to this talk you are probably well aware of Are.na. So many people create the same app, but each is slightly different.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/arena.png">
              <p>I want to highlight Are.na in particular because it was made 14 years ago, around the same time Instagram was made. What really set it apart was its revenue model, in which it doesn't have ads or collect user data as a way of monetization or any sort of algorithm. It makes money through subscriptions that people who use the app pay. People often say Are.na is "hipster pinterest" but more accurately it is a platform in which you can participate in to resist the enshittification of technology.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/cover/talk.png">
              <p>I believe that technology becomes a choice because we all these different options to choose from and we can choose the one that stands with our values and how we view the world. </p></br>
                <p>I think technological disruption is more about seeing what you want to see in the world. One of the positive sides to vibe coding or AI assisted coding tools is a new sense of accessibility. People who were previously scared or didn't think they were smart enough to make software can now make it themselves and put into the world what they want to see.</p>
            </div>

            <div class="slide-section" data-image="" data-bg-image="./image/home.gif">
              <p><em>Building becomes a new kind of freedom. A freedom to reimagine the world and what we want to see it become.</em></p>
            </div>
          </div>
          
          <div class="slide-image-container">
            <img id="slide-image" src="./image/cover/linkdump.png" alt="" />
          </div>
        </div>
      </div>
      
      <div class="embeds-section">
        <p>This is a transcript of my Chinatown.js talk. You can look through the slides here or the YouTube link below (warning: the microphone rings).
      </br>For more of my writing and research, visit my substack <a href="https://corny.substack.com/" target="_blank">here</a>.</p>
        <div class="line">
        <iframe style="border: 1px solid rgba(0, 0, 0, 0.1);" width="500" height="350" src="https://embed.figma.com/proto/IkBSDHIleM3dVeXPGx2OPt/Presentation?page-id=0%3A1&node-id=1-3&p=f&viewport=-17554%2C-1576%2C0.31&scaling=scale-down&content-scaling=fixed&starting-point-node-id=1%3A3&embed-host=share" allowfullscreen></iframe>
        
        <iframe width="500" height="250" src="https://www.youtube.com/embed/LaKQvJyXimg?si=T5LjeKsR1ysX1Akn" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
      </div>
      </div>
    </div>
    <script src="./nav-loader.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const slideSections = document.querySelectorAll('.slide-section');
        const slideImage = document.getElementById('slide-image');
        const scrollContainer = document.querySelector('.col');
        const backgroundLayer = document.getElementById('background-layer');
        
        // Cache for extracted GIF colors
        const gifColorCache = {};
        
        // Check if URL is a GIF
        function isGif(url) {
          if (!url) return false;
          return url.toLowerCase().endsWith('.gif');
        }
        
        // Convert RGB to HSL
        function rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            
            switch (max) {
              case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
              case g: h = ((b - r) / d + 2) / 6; break;
              case b: h = ((r - g) / d + 4) / 6; break;
            }
          }
          
          return [h * 360, s * 100, l * 100];
        }
        
        // Convert HSL to RGB
        function hslToRgb(h, s, l) {
          h /= 360;
          s /= 100;
          l /= 100;
          
          let r, g, b;
          
          if (s === 0) {
            r = g = b = l;
          } else {
            const hue2rgb = (p, q, t) => {
              if (t < 0) t += 1;
              if (t > 1) t -= 1;
              if (t < 1/6) return p + (q - p) * 6 * t;
              if (t < 1/2) return q;
              if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
              return p;
            };
            
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
          }
          
          return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }
        
        // Extract dominant color from image (GIF first frame)
        function extractDominantColor(imageUrl) {
          return new Promise((resolve, reject) => {
            // Check cache first
            if (gifColorCache[imageUrl]) {
              resolve(gifColorCache[imageUrl]);
              return;
            }
            
            const img = new Image();
            img.crossOrigin = 'anonymous';
            
            img.onload = function() {
              try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = Math.min(img.width, 200);
                canvas.height = Math.min(img.height, 200);
                
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                // Sample pixels (every 10th pixel for performance)
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                const colorCounts = {};
                
                // Sample pixels
                for (let i = 0; i < data.length; i += 40) { // Every 10th pixel (RGBA = 4 bytes)
                  const r = data[i];
                  const g = data[i + 1];
                  const b = data[i + 2];
                  const a = data[i + 3];
                  
                  // Skip transparent pixels
                  if (a < 128) continue;
                  
                  // Quantize colors to reduce noise
                  const qr = Math.floor(r / 10) * 10;
                  const qg = Math.floor(g / 10) * 10;
                  const qb = Math.floor(b / 10) * 10;
                  const key = `${qr},${qg},${qb}`;
                  
                  colorCounts[key] = (colorCounts[key] || 0) + 1;
                }
                
                // Find most common color
                let maxCount = 0;
                let dominantKey = null;
                for (const key in colorCounts) {
                  if (colorCounts[key] > maxCount) {
                    maxCount = colorCounts[key];
                    dominantKey = key;
                  }
                }
                
                if (dominantKey) {
                  const [r, g, b] = dominantKey.split(',').map(Number);
                  const color = { r, g, b };
                  gifColorCache[imageUrl] = color;
                  resolve(color);
                } else {
                  // Fallback to average color
                  let totalR = 0, totalG = 0, totalB = 0, count = 0;
                  for (let i = 0; i < data.length; i += 40) {
                    if (data[i + 3] >= 128) {
                      totalR += data[i];
                      totalG += data[i + 1];
                      totalB += data[i + 2];
                      count++;
                    }
                  }
                  if (count > 0) {
                    const color = {
                      r: Math.round(totalR / count),
                      g: Math.round(totalG / count),
                      b: Math.round(totalB / count)
                    };
                    gifColorCache[imageUrl] = color;
                    resolve(color);
                  } else {
                    reject(new Error('Could not extract color'));
                  }
                }
              } catch (error) {
                reject(error);
              }
            };
            
            img.onerror = function() {
              reject(new Error('Failed to load image'));
            };
            
            img.src = imageUrl;
          });
        }
        
        // Lighten and desaturate color
        function lightenAndDesaturate(r, g, b) {
          const [h, s, l] = rgbToHsl(r, g, b);
          // Increase lightness (target around 85-90%)
          const newL = Math.min(90, l + (90 - l) * 0.6);
          // Decrease saturation (reduce by 40-50%)
          const newS = Math.max(10, s * 0.5);
          const [newR, newG, newB] = hslToRgb(h, newS, newL);
          return `rgb(${newR}, ${newG}, ${newB})`;
        }
        
        // Update background based on image or custom colors
        function updateBackground(imageUrl, section) {
          if (!backgroundLayer) return;
          
          // Check if section has a specific background image for blur effect
          const bgImage = section?.getAttribute('data-bg-image');
          if (bgImage) {
            // Use the specified background image with blur
            backgroundLayer.style.backgroundImage = `url(${bgImage})`;
            backgroundLayer.style.backgroundColor = 'transparent';
            backgroundLayer.classList.remove('color-mode');
            
            // Reset text color (but preserve elements with data-preserve-color)
            if (section) {
              section.style.color = '';
              const childElements = section.querySelectorAll('p, h3, h4, a, em');
              childElements.forEach(el => {
                // Only reset if element doesn't have data-preserve-color attribute
                if (!el.hasAttribute('data-preserve-color')) {
                  el.style.color = '';
                }
              });
            }
            return;
          }
          
          // Check if section has custom colors (when no image)
          const bgColor = section?.getAttribute('data-bg-color');
          const textColor = section?.getAttribute('data-text-color');
          
          // If no image but custom colors are specified
          if (!imageUrl && bgColor) {
            backgroundLayer.style.backgroundColor = bgColor;
            backgroundLayer.style.backgroundImage = 'none';
            backgroundLayer.classList.add('color-mode');
            
            // Apply text color to the section if specified
            if (textColor && section) {
              section.style.color = textColor;
              // Also apply to all child elements (but preserve elements with data-preserve-color)
              const childElements = section.querySelectorAll('p, h3, h4, a, em');
              childElements.forEach(el => {
                if (!el.hasAttribute('data-preserve-color')) {
                  el.style.color = textColor;
                }
              });
            }
            return;
          }
          
          // If no image and no custom colors, use default
          if (!imageUrl) {
            backgroundLayer.style.backgroundColor = 'rgb(240, 240, 240)';
            backgroundLayer.style.backgroundImage = 'none';
            backgroundLayer.classList.add('color-mode');
            return;
          }
          
          // Reset text color when image is present (but preserve elements with data-preserve-color)
          if (section) {
            section.style.color = '';
            const childElements = section.querySelectorAll('p, h3, h4, a, em');
            childElements.forEach(el => {
              // Only reset if element doesn't have data-preserve-color attribute
              if (!el.hasAttribute('data-preserve-color')) {
                el.style.color = '';
              }
            });
          }
          
          if (isGif(imageUrl)) {
            // For GIFs, extract color and use as background
            extractDominantColor(imageUrl)
              .then(color => {
                const bgColor = lightenAndDesaturate(color.r, color.g, color.b);
                backgroundLayer.style.backgroundColor = bgColor;
                backgroundLayer.style.backgroundImage = 'none';
                backgroundLayer.classList.add('color-mode');
              })
              .catch(error => {
                console.warn('Failed to extract color from GIF:', error);
                // Check for custom fallback colors
                if (bgColor) {
                  backgroundLayer.style.backgroundColor = bgColor;
                } else {
                  backgroundLayer.style.backgroundColor = 'rgb(240, 240, 240)';
                }
                backgroundLayer.style.backgroundImage = 'none';
                backgroundLayer.classList.add('color-mode');
              });
          } else {
            // For regular images, use blurred version
            backgroundLayer.style.backgroundImage = `url(${imageUrl})`;
            backgroundLayer.style.backgroundColor = 'transparent';
            backgroundLayer.classList.remove('color-mode');
          }
        }
        
        // Function to check if mobile (40em = 640px)
        function isMobileView() {
          return window.innerWidth <= 640;
        }
        
        // Function to add images to sections for mobile
        function addImagesToSections() {
          slideSections.forEach(function(section) {
            // Check if image already exists
            if (section.querySelector('.section-image')) {
              return;
            }
            const imageUrl = section.getAttribute('data-image');
            if (imageUrl) {
              const img = document.createElement('img');
              img.src = imageUrl;
              img.className = 'section-image';
              img.alt = '';
              section.appendChild(img);
            }
          });
        }
        
        // Handle window resize - check if we need to switch between mobile/desktop
        let resizeTimeout;
        window.addEventListener('resize', function() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(function() {
            if (isMobileView()) {
              addImagesToSections();
            }
          }, 100);
        });
        
        // On mobile, add images directly to each section
        if (isMobileView()) {
          addImagesToSections();
          // Also run on load to ensure images are added
          setTimeout(addImagesToSections, 100);
          return; // Don't run the scroll-based image update on mobile
        }
        
        if (slideSections.length === 0 || !slideImage || !scrollContainer) {
          console.log('Missing elements:', { 
            slideSections: slideSections.length, 
            slideImage: !!slideImage,
            scrollContainer: !!scrollContainer
          });
          return;
        }
        
        // Set initial image
        const firstSection = slideSections[0];
        const firstImage = firstSection.getAttribute('data-image');
        if (firstImage) {
          slideImage.src = firstImage;
          updateBackground(firstImage, firstSection);
        } else {
          // No image, check for custom colors
          updateBackground(null, firstSection);
        }
        
        // Preload all images
        const imageUrls = Array.from(slideSections).map(section => 
          section.getAttribute('data-image')
        ).filter(Boolean);
        
        imageUrls.forEach(url => {
          const img = new Image();
          img.src = url;
        });
        
        // Pre-extract colors for all GIFs
        imageUrls.forEach(url => {
          if (isGif(url)) {
            extractDominantColor(url).catch(() => {
              // Silently fail for pre-extraction
            });
          }
        });
        
        // Helper to normalize URLs for comparison
        function normalizeUrl(url) {
          if (!url) return '';
          const a = document.createElement('a');
          a.href = url;
          return a.href;
        }
        
        let currentImageUrl = normalizeUrl(firstImage);
        
        // Function to update image based on scroll position
        function updateImageOnScroll() {
          const scrollTop = scrollContainer.scrollTop;
          const containerHeight = scrollContainer.clientHeight;
          const viewportCenter = scrollTop + containerHeight / 2;
          
          let activeSection = null;
          let minDistance = Infinity;
          
          slideSections.forEach((section, index) => {
            // Get position relative to scroll container
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            const sectionCenter = sectionTop + sectionHeight / 2;
            
            // Calculate distance from viewport center
            const distance = Math.abs(sectionCenter - viewportCenter);
            
            if (distance < minDistance) {
              minDistance = distance;
              activeSection = section;
            }
          });
          
          if (activeSection) {
            const imageUrl = activeSection.getAttribute('data-image');
            const normalizedUrl = normalizeUrl(imageUrl);
            
            if (currentImageUrl !== normalizedUrl) {
              currentImageUrl = normalizedUrl;
              
              // Update background (pass section for custom colors)
              updateBackground(imageUrl, activeSection);
              
              if (imageUrl) {
                // Fade out
                slideImage.style.display = 'block';
                slideImage.classList.add('fade-out');
                
                // Change image after fade starts
                setTimeout(() => {
                  slideImage.src = imageUrl;
                  slideImage.classList.remove('fade-out');
                }, 250);
              } else {
                // No image, hide the image container
                slideImage.style.display = 'none';
              }
            }
          }
        }
        
        // Update on scroll with throttling
        let scrollTimeout;
        scrollContainer.addEventListener('scroll', function() {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(updateImageOnScroll, 50);
        });
        
        // Also use requestAnimationFrame for smoother updates
        function rafUpdate() {
          updateImageOnScroll();
          requestAnimationFrame(rafUpdate);
        }
        requestAnimationFrame(rafUpdate);
        
        // Initial update
        updateImageOnScroll();
      });
    </script>
  </body>
</html>