<!DOCTYPE html>
<html lang="en">
  <link rel="stylesheet" href="./global.css" type="text/css" />
  <link rel="stylesheet" href="./styles.css" type="text/css" />
  <script src="./cursor.js" defer></script>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Software with a Point of View - Chinatown.js talk August 14 2025" />
    <title>Software with a Point of View</title>
    <style>
      /* Prevent scroll restoration and ensure page starts at top */
      html {
        scroll-behavior: auto;
      }
      body {
        overflow-x: hidden;
        gap: 0 !important;
      }
      /* Remove body background on desktop for valuesbasedsoftware.html */
      @media only screen and (min-width: 40.01em) {
        body {
          background-image: none;
        }
      }
      
      /* Scroll snapping */
      .col {
        scroll-snap-type: y proximity;
        scroll-behavior: smooth;
      }
      
      .slide-section {
        scroll-snap-align: center;
        scroll-snap-stop: normal;
      }
      
      /* Dark brown text for home.gif section */
      .slide-section{
        color: #503428;
      }
      
      .slide-section p, em {
        color: #503428;
      }
      
      /* Lighter background filter */
      .background-layer,
      .background-layer.layer-2 {
        filter: blur(24px);
        opacity: 0.5;
      }
      
      /* Grid-based layout overrides - keep grid structure stable */
      .slide-container {
        display: grid;
        grid-template-columns: minmax(480px, 550px) minmax(600px, 700px);
        gap: 164px;
        width: 100%;
        align-items: start;
      }
      
      .slide-content {
        padding-left: 32px;
        padding-right: 24px;
        max-width: 600px;
        transition: grid-column 0.3s ease-out, max-width 0.3s ease-out, margin 0.3s ease-out;
      }
      
      /* When there's no image, hide image container and let content span both columns */
      .slide-container.no-image .slide-image-container {
        display: none;
      }
      
      .slide-container.no-image .slide-content {
        grid-column: 1 / -1;
        max-width: 800px;
        margin: 0 auto;
      }
      
      .back-link {
        left: 32px;
      }
      
      .slide-image-container {
        width: 100%;
        height: calc(100vh - 24px);
        padding-right: 32px;
      }
      
      .slide-image-container img {
        max-width: 100%;
        max-height: 100%;
        width: auto;
        height: auto;
        object-fit: contain;
        transition: filter 0.15s ease-out;
        will-change: filter;
      }
      
      .embeds-section {
        grid-template-columns: minmax(480px, 550px) minmax(600px, 700px);
        padding: 0;
        margin-top: 40px;
      }
      
      .embeds-container {
        display: grid;
        gap: 48px;
        width: 100%;
        align-items: start;
      }
      
      .embeds-content {
        padding-left: 32px;
        padding-right: 24px;
      }
      
      .embeds-content p {
        font-size: 1.2rem;
        margin-bottom: 16px;
      }
      
      .embeds-right {
        width: 100%;
        padding-right: 32px;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      
      .embeds-right iframe {
        /* width: auto; */
        /* max-width: 100%; */
        margin-bottom: 0;
      }
      
      /* Mobile: single column grid */
      @media only screen and (max-width: 40em) {
        .slide-container {
          display: flex;
          flex-direction: column;
          gap: 20px;
        }
        
        .slide-content {
          padding-left: 16px;
          padding-right: 16px;
        }
        
        .back-link {
          left: 16px;
        }
        
        .embeds-container {
          display: flex;
          flex-direction: column;
          gap: 20px;
        }
        
        .embeds-content {
          padding-left: 16px;
          padding-right: 16px;
        }
        
        .embeds-right {
          padding-left: 16px;
          padding-right: 16px;
        }
        
        .embeds-right iframe {
          width: 100%;
          max-width: 100%;
        }
        
        .slide-section .section-image {
          width: 100%;
          max-height: 60vh;
          object-fit: contain;
        }
      }
      
      /* Larger screens (1920px and wider) - increase font sizes */
      @media only screen and (min-width: 1920px) {
        .slide-section p {
          font-size: 1.75rem;
          line-height: 1.7;
        }
        
        .slide-section h3 {
          font-size: 2.5rem;
        }
        
        .slide-section h4 {
          font-size: 2.2rem;
        }
        
        .embeds-content p {
          font-size: 1.4rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="background-layer layer-2" id="background-layer-2"></div>
    <div class="background-layer" id="background-layer"></div>
    <div class="blob"></div>
    <div class="col">

  
      <div class="line">
        <div class="slide-container">
          <div class="slide-content">
            <a href="index.html" class="back-link"><p>‚Üê back to connie.surf</p></a>
            <!-- 
              To use custom colors when there's no image, add:
              data-bg-color="rgb(255, 200, 100)" (or any CSS color value)
              data-text-color="rgb(50, 50, 50)" (or any CSS color value)
              
              To use a blurred image in the background (separate from the slide image), add:
              data-bg-image="./path/to/image.webp"
              
              Examples:
              <div class="slide-section" data-bg-color="#ff6b6b" data-text-color="#ffffff">
              <div class="slide-section" data-image="./slide.webp" data-bg-image="./blurred-bg.webp">
            -->
            <div class="slide-section" data-image="./image/slides/panning.gif" data-bg-image="./image/slides/newonboarding.webp">
              <h3>Software with a Point of View</h3>
              <p style="color: rgb(132, 137, 141);"><em>Chinatown.js talk, August 14 2025</em></p>
            </br>
          </br>
              <p>PART 1: THE CONCEPT BEHIND LINK DUMP</p>
        </br>
              <p>The beginning of this talk is about <a href="https://linkdump.connie.surf" target="_blank">Link Dump</a>, an ephemeral link canvas I made where the links pasted will eventually disappear and remain as an exportable csv.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/slide2.webp" data-bg-image="./image/slides/newonboarding.webp">
              <p>While creating this project I went against the normal design process that I follow during my day job as a product designer. I ended up ultimately designing for myself, more specifically, for the values I believe in. </p>
              </br>
              <p>The first value being the urgency to finish creative work and the second being a manifestation of feelings I had about data on the internet.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/slide3.webp">
              <p>The urgency was because I would take notoriously long to finish creative projects. As a serial digital hoarder, I used to save so much - screenshots, notes, photos and links - with the intent of synthesizing and creating. In the end, it would remain an ever running to-do list. </p>
                </br>
                <p>At the same time I had read <em>The Creative Act</em>, where Rick Rubin quotes creativity as a universal force where if you don't act upon it, it would disappear and manifest elsewhere.</p>
            </div>
            <div class="slide-section" data-bg-image="./image/slides/newonboarding.webp" data-image="./image/slides/idle.gif">
              <p>That sparked the first iteration of Link Dump. You could paste or import links as cards on the canvas and set a time limit for when you wanted to finish your project. The cards would age with time and when the time limit passed the canvas would erase itself. The passage of time also manifested as a screensaver that would appear if you left your tab idle for too long.</p>
            </div>
              <div class="slide-section" data-image="./image/slides/cloud.webp">
              <p>The second part was I wanted to create lighter software. The temporal aspect was important because I had a personal belief that the internet remembered too much.</p>
                </br>
                <p>When we think of cloud storage, we think of it as a weightless entity. However, the internet has an immense physicality to it from data centers in the midwest to huge cables under the ocean. As the internet becomes more integral to our lives, its physical presence only grows.</p>
                </br>
                <p>Furthermore, data is actually a huge monetization lever, and companies don't have an incentive to make it easy to mass delete items. The easier solution is just to subscribe and upgrade to unlimited cloud storage and continue to accumulate.</p>
              </div>
              <div class="slide-section" data-image="./image/slides/save.webp">
                <p>As a result, in my first iteration you can do everything locally. Data would be locally stored in the browser and you could eventually export it to your own hard drive when the time was up.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/tiktok.webp">
              <p>Allowing the user to own their data was also important to me because we don't realize that our data is owned by large corporations that can disappear at any second. Earlier in 2025, Tiktok was banned and they let you export your data as a huge CSV, but you couldn't actually save your Tiktoks because the CSV linked out to the Tiktok site as well.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/tumblr.webp">
              <p class="desktop-only-text" style="color: rgb(206, 171, 98)" data-preserve-color="true">But beyond the technicalities of it all, my motivations can be summarized from this one picture I saw on tumblr when I was 16.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/putitdown.webp" data-bg-image="./image/slides/arenabg2.webp">
              <p>We hold on and notice and collect, but we never really put it down. Putting it down is how you process and create and engage with the world around you. It's how you ultimately remember.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/process.webp" data-bg-image="./image/slides/process.webp">
              <p>PART 2: THE PROCESS OF MAKING LINK DUMP</p>
              <p>Beyond the end result, the process was equally as important. I created the bulk of this project between the months of March to May. I'm a designer who before this, only knew HTML, CSS and Javascript. I knew how components worked in React but I never did state management before or connected to a database.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.webp" data-image="./image/slides/output.gif">
              <p>As I've mentioned before the typical design process would be exploring and testing a prototype on Figma and building it in increments.</p>
            </br>
              <p>What I actually did was a linear process where I built out what I thought was the MVP and then kept on redoing it. The first version was just a draggable card canvas with a timer.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.webp" data-image="./image/slides/demo.webp">
              <p>After that I wanted to demo it at an art event and have a participatory aspect where people contribute their links onto a group collaborative board. I then introduced a board that anyone could access via a link and had cross-device syncing and collaboration. People could upload an image from their phone and it would show up in the browser window.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.webp" data-image="./image/slides/modal.gif">
              <p>Then I decided it would be a good idea to show my app to some people and ask them if they would use it. At this point, a particular feature I was proud of was this glossy modal that smoothly transitioned from the onboarding directions to the board creation screen. When I tested it some friends told me that there was too much text and inputs in the modal and they weren't going to read it.That was when I realized I needed a new onboarding mode.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/fullonboarding.webp">
              <p>I recoded it again and now on your first time viewing Link Dump, it immediately opens to a canvas that has some cards explaining what's going on. I also simplified the board creation modal to have more defaults so you don't really have to fill out much to get started and it begins.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/overload.webp">
              <p>After showing it to some people, I decided it was time to use it myself to write an essay. I had been writing an <a href="decay.connie.surf" target="_blank"> essay</a> about the underpinnings of this project, which I called the "Organic web". After importing and organizing the links from my <a href="https://www.are.na/connie-liu-kg4ypfp7ry0/organic-web" target="_blank">are.na board</a> I realized that I had put the links into groups. Unfortunately the CSV export did not remember these groups I had created and I couldn't label them. At this point I thought if I could just build out grouping, then I could finally be done with this project.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/dark.webp">
              <p>It was also around this point I did not understand some parts of my code base anymore. Because I was using AI to assist with the state management, I started to break my code with the further changes I made. At this point I started to feel really frustrated, I had spent hundreds of hours creating slightly buggy software and I couldn't figure out how to add the final feature to allow myself to actually use it.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/dark.webp">
              <p>So what was the reason to keep doing this?</p>
              </br>
              <p>After a certain point of doing product design you start to realize that you will always be designing for a business, and a business it has to make money. A lot of things you design end up as monetization levers. When it occurs to an extreme, it's called enshittification.</p>
            </br> <p> Enshittification describes how companies first offer high quality services but then because they are backed by venture capital, they have to implement some decisions at cost for the user to maximize profits and exhibit growth.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/dark.webp">
              <p>I started to wonder, is there even a way to make software that is "good"? What is good anyways? If you go to the silicon valley startup scene, "good" would be "what is a niche saas market where I can follow basic design principles to make it easy do the main task and also use AI".</p>
            </br>
            <p>To me, I think of "good" software as a vector for reimagining. </p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/newonboarding.webp" data-image="./image/slides/article.webp">
                <p>
                I recently read <a href="https://harpers.org/archive/2025/06/the-reenchanted-world-karl-ove-knausgaard-digital-age/" target="_blank">this article</a> in which two authors are discussing the state of the world. One of the authors, James, wrote this book about all the bad things tech is doing. He comes to the conclusion that we are screwed because the current system we live in keeps the existing power dynamics and there's no interest in educating on how it works. After he writes the first book, he becomes quite depressed and finds his way out through making things. The conclusion he comes to is that when you make your own technology, you can make something different and upset the existing power balance. Making is something that people are doing all the time and that you can do yourself.
              </p></br> <p> That leads me to my answer which is <strong>values based software</strong>.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/arenabg2.webp" data-image="./image/slides/software.webp">
              <p>PART 3: VALUES BASED SOFTWARE</p>
            </br>
              <p>I'll explain this concept through an anecdote. There are so many websites where you save and categorize. There is Pinterest, and Cosmos, and Silk and River and if you're listening to this talk you are probably well aware of Are.na. So many people create the same app, but each is slightly different.</p>
            </div>

            <div class="slide-section" data-image="./image/slides/arena.webp">
              <p>I want to highlight Are.na in particular because it was made 14 years ago, around the same time Instagram was made. What really set it apart was its revenue model, in which it doesn't have ads or collect user data as a way of monetization or any sort of algorithm. It makes money through users paying a premium subscription. People often say Are.na is "hipster pinterest" but more accurately it is a platform in which you can participate in to resist the enshittification of technology.</p>
            </div>

            <div class="slide-section" data-bg-image="./image/slides/light.webp">
              <p>I believe that technology becomes a choice because when there are different options to choose from and we can choose the one that stands with our values and how we view the world. </p></br>
                <p>I think technological disruption is more about seeing what you want to see in the world. One of the positive sides to vibe coding or AI assisted coding tools is a new sense of accessibility. People who were previously scared or didn't think they were smart enough to make software can now make it themselves and put into the world what they want to see.</p>
            </div>

            <div class="slide-section" data-image=""  data-bg-image="./image/slides/light.webp">
              <p><em>Building becomes a new kind of freedom. A freedom to reimagine the world and what we want to see it become.</em></p>
            </div>
            <div class="slide-section" data-image=""  data-bg-image="./image/slides/light.webp">
              <p>This is a transcript of my Chinatown.js talk. You can look through the slides here or the YouTube link below (warning: the microphone rings).</p>
              </br>
              <p>Related writing: <a href="https://decay.connie.surf/">The Organic Web</a>, <a href="https://corny.substack.com/p/on-collecting-and-saving-the-past">On Collecting and Saving the Past</a>, <a href="https://corny.substack.com/p/on-ui-as-a-metaphor">On UI as a Metaphor</a></p>
               <p> For more of my writing and research, visit my substack <a href="https://corny.substack.com/" target="_blank">here</a>.</p>
            </br>
            <div class="line">
            <iframe style="border: 1px solid rgba(0, 0, 0, 0.1);" width="400" height="300" src="https://embed.figma.com/proto/IkBSDHIleM3dVeXPGx2OPt/Presentation?page-id=0%3A1&node-id=1-3&p=f&viewport=-17554%2C-1576%2C0.31&scaling=scale-down&content-scaling=fixed&starting-point-node-id=1%3A3&embed-host=share" allowfullscreen></iframe>
            
            <iframe width="400" height="315" src="https://www.youtube.com/embed/LaKQvJyXimg?si=fxi3vqnpYuwcWkcN" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>          </div>
          </div>
          </div>
          
          <div class="slide-image-container" data-bg-image="./image/slides/light.webp">
            <img id="slide-image" src="./image/cover/linkdump.webp" alt="" />
          </div>
        </div>
      </div>
      
        
    <script src="./nav-loader.js"></script>
    <script>
      // Prevent browser scroll restoration
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }
      
      document.addEventListener('DOMContentLoaded', function() {
        const slideSections = document.querySelectorAll('.slide-section');
        const slideImage = document.getElementById('slide-image');
        const scrollContainer = document.querySelector('.col');
        const backgroundLayer = document.getElementById('background-layer');
        
        // Get the second background layer (already exists in HTML)
        const backgroundLayer2 = document.getElementById('background-layer-2');
        
        // Track which layer is currently visible
        let currentLayer = 1; // 1 or 2
        
        // Ensure scroll position is at top on initial load (multiple attempts to override browser behavior)
        if (scrollContainer) {
          scrollContainer.scrollTop = 0;
          // Force scroll to top after a brief delay to override any browser restoration
          setTimeout(() => {
            scrollContainer.scrollTop = 0;
            window.scrollTo(0, 0);
          }, 0);
          setTimeout(() => {
            scrollContainer.scrollTop = 0;
          }, 50);
        }
        
        // Preload an image and return a promise
        function preloadImage(url) {
          return new Promise((resolve, reject) => {
            if (!url) {
              resolve();
              return;
            }
            const img = new Image();
            img.onload = () => resolve();
            img.onerror = () => reject(new Error('Failed to load image'));
            img.src = url;
          });
        }
        
        // Update background based on image or custom colors using crossfade
        function updateBackground(imageUrl, section) {
          if (!backgroundLayer || !backgroundLayer2) return;
          
          // Determine which layers are front and back
          const frontLayer = currentLayer === 1 ? backgroundLayer : backgroundLayer2;
          const backLayer = currentLayer === 1 ? backgroundLayer2 : backgroundLayer;
          
          // Check if section has a specific background image for blur effect
          const bgImage = section?.getAttribute('data-bg-image');
          if (bgImage) {
            // Preload the new image first
            preloadImage(bgImage).then(() => {
              // Set the new image on the back layer
              backLayer.style.backgroundImage = `url(${bgImage})`;
              backLayer.style.backgroundColor = 'transparent';
              backLayer.classList.remove('color-mode');
              backLayer.style.opacity = '0';
              
              // Crossfade: fade out front, fade in back
              frontLayer.style.opacity = '0';
              backLayer.style.opacity = '0.8';
              
              // Swap layers
              currentLayer = currentLayer === 1 ? 2 : 1;
            }).catch(() => {
              // If preload fails, just update directly
              frontLayer.style.backgroundImage = `url(${bgImage})`;
              frontLayer.style.backgroundColor = 'transparent';
              frontLayer.classList.remove('color-mode');
            });
            
            // Reset text color (but preserve elements with data-preserve-color)
            if (section) {
              section.style.color = '';
              const childElements = section.querySelectorAll('p, h3, h4, a, em');
              childElements.forEach(el => {
                if (!el.hasAttribute('data-preserve-color')) {
                  el.style.color = '';
                }
              });
            }
            return;
          }
          
          // Check if section has custom colors (when no image)
          const bgColor = section?.getAttribute('data-bg-color');
          const textColor = section?.getAttribute('data-text-color');
          
          // If no image but custom colors are specified
          if (!imageUrl && bgColor) {
            // For color changes, we can crossfade smoothly
            backLayer.style.backgroundColor = bgColor;
            backLayer.style.backgroundImage = 'none';
            backLayer.classList.add('color-mode');
            backLayer.style.opacity = '0';
            
            frontLayer.style.opacity = '0';
            backLayer.style.opacity = '0.8';
            
            currentLayer = currentLayer === 1 ? 2 : 1;
            
            // Apply text color to the section if specified
            if (textColor && section) {
              section.style.color = textColor;
              const childElements = section.querySelectorAll('p, h3, h4, a, em');
              childElements.forEach(el => {
                if (!el.hasAttribute('data-preserve-color')) {
                  el.style.color = textColor;
                }
              });
            }
            return;
          }
          
          // If no image and no custom colors, use default
          if (!imageUrl) {
            backLayer.style.backgroundColor = 'rgb(240, 240, 240)';
            backLayer.style.backgroundImage = 'none';
            backLayer.classList.add('color-mode');
            backLayer.style.opacity = '0';
            
            frontLayer.style.opacity = '0';
            backLayer.style.opacity = '0.8';
            
            currentLayer = currentLayer === 1 ? 2 : 1;
            return;
          }
          
          // Reset text color when image is present (but preserve elements with data-preserve-color)
          if (section) {
            section.style.color = '';
            const childElements = section.querySelectorAll('p, h3, h4, a, em');
            childElements.forEach(el => {
              if (!el.hasAttribute('data-preserve-color')) {
                el.style.color = '';
              }
            });
          }
          
          // For all images, use blurred version with crossfade
          preloadImage(imageUrl).then(() => {
            backLayer.style.backgroundImage = `url(${imageUrl})`;
            backLayer.style.backgroundColor = 'transparent';
            backLayer.classList.remove('color-mode');
            backLayer.style.opacity = '0';
            
            frontLayer.style.opacity = '0';
            backLayer.style.opacity = '0.8';
            
            currentLayer = currentLayer === 1 ? 2 : 1;
          }).catch(() => {
            // If preload fails, update directly without crossfade
            frontLayer.style.backgroundImage = `url(${imageUrl})`;
            frontLayer.style.backgroundColor = 'transparent';
            frontLayer.classList.remove('color-mode');
          });
        }
        
        // Function to check if mobile (40em = 640px)
        function isMobileView() {
          return window.innerWidth <= 640;
        }
        
        // Function to add images to sections for mobile
        function addImagesToSections() {
          slideSections.forEach(function(section) {
            // Check if image already exists
            if (section.querySelector('.section-image')) {
              return;
            }
            const imageUrl = section.getAttribute('data-image');
            if (imageUrl) {
              const img = document.createElement('img');
              img.src = imageUrl;
              img.className = 'section-image';
              img.alt = '';
              section.appendChild(img);
            }
          });
        }
        
        // Handle window resize - check if we need to switch between mobile/desktop
        let resizeTimeout;
        window.addEventListener('resize', function() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(function() {
            if (isMobileView()) {
              addImagesToSections();
            }
          }, 100);
        });
        
        // On mobile, add images directly to each section
        if (isMobileView()) {
          addImagesToSections();
          // Also run on load to ensure images are added
          setTimeout(addImagesToSections, 100);
          return; // Don't run the scroll-based image update on mobile
        }
        
        if (slideSections.length === 0 || !slideImage || !scrollContainer) {
          console.log('Missing elements:', { 
            slideSections: slideSections.length, 
            slideImage: !!slideImage,
            scrollContainer: !!scrollContainer
          });
          return;
        }
        
        // Set initial image and background immediately (before any scroll calculations)
        const firstSection = slideSections[0];
        const firstImage = firstSection.getAttribute('data-image');
        const firstBgImage = firstSection.getAttribute('data-bg-image');
        
        // Initialize both layers with the same initial background
        const initializeLayer = (layer, bgImage, image, section) => {
          if (bgImage) {
            layer.style.backgroundImage = `url(${bgImage})`;
            layer.style.backgroundColor = 'transparent';
            layer.classList.remove('color-mode');
            layer.style.opacity = '0.8';
          } else if (image && image.trim()) {
            layer.style.backgroundImage = `url(${image})`;
            layer.style.backgroundColor = 'transparent';
            layer.classList.remove('color-mode');
            layer.style.opacity = '0.8';
          } else {
            const bgColor = section?.getAttribute('data-bg-color');
            if (bgColor) {
              layer.style.backgroundColor = bgColor;
              layer.style.backgroundImage = 'none';
              layer.classList.add('color-mode');
            } else {
              layer.style.backgroundColor = 'rgb(240, 240, 240)';
              layer.style.backgroundImage = 'none';
              layer.classList.add('color-mode');
            }
            layer.style.opacity = '0.8';
          }
        };
        
        // Initialize both layers
        initializeLayer(backgroundLayer, firstBgImage, firstImage, firstSection);
        initializeLayer(backgroundLayer2, firstBgImage, firstImage, firstSection);
        
        // Make sure layer 2 is hidden initially
        backgroundLayer2.style.opacity = '0';
        
        // Then update image and background properly
        const slideContainer = document.querySelector('.slide-container');
        const imageContainer = document.querySelector('.slide-image-container');
        
        if (firstImage && firstImage.trim()) {
          slideImage.src = firstImage;
          slideImage.style.display = 'block';
          if (imageContainer) {
            imageContainer.style.display = '';
          }
          if (slideContainer) {
            slideContainer.classList.remove('no-image');
          }
          updateBackground(firstImage, firstSection);
        } else {
          // No image, check for custom colors or data-bg-image
          slideImage.style.display = 'none';
          if (imageContainer) {
            imageContainer.style.display = 'none';
          }
          if (slideContainer) {
            slideContainer.classList.add('no-image');
          }
          updateBackground(null, firstSection);
        }
        
        // Preload all images (both data-image and data-bg-image) for smoother transitions
        const imageUrls = Array.from(slideSections).map(section => 
          section.getAttribute('data-image')
        ).filter(Boolean);
        
        const bgImageUrls = Array.from(slideSections).map(section => 
          section.getAttribute('data-bg-image')
        ).filter(Boolean);
        
        // Preload all slide images and background images
        const allImageUrls = [...new Set([...imageUrls, ...bgImageUrls])]; // Remove duplicates
        allImageUrls.forEach(url => {
          const img = new Image();
          img.src = url;
        });
        
        // Helper to normalize URLs for comparison
        function normalizeUrl(url) {
          if (!url) return '';
          const a = document.createElement('a');
          a.href = url;
          return a.href;
        }
        
        // Treat empty string as empty for comparison
        let currentImageUrl = firstImage && firstImage.trim() ? normalizeUrl(firstImage) : '';
        
        // Track if initial load is complete
        let initialLoadComplete = false;
        
        // Function to update image based on scroll position
        function updateImageOnScroll() {
          // On initial load, ensure we're at the top
          if (!initialLoadComplete && scrollContainer.scrollTop > 0) {
            scrollContainer.scrollTop = 0;
            initialLoadComplete = true;
          }
          
          const scrollTop = scrollContainer.scrollTop;
          const containerHeight = scrollContainer.clientHeight;
          const viewportCenter = scrollTop + containerHeight / 2;
          
          let activeSection = null;
          let minDistance = Infinity;
          
          slideSections.forEach((section, index) => {
            // Get position relative to scroll container
            const sectionTop = section.offsetTop;
            const sectionHeight = section.offsetHeight;
            const sectionCenter = sectionTop + sectionHeight / 2;
            
            // Calculate distance from viewport center
            const distance = Math.abs(sectionCenter - viewportCenter);
            
            if (distance < minDistance) {
              minDistance = distance;
              activeSection = section;
            }
          });
          
          if (activeSection) {
            const imageUrl = activeSection.getAttribute('data-image');
            // Treat empty string as null
            const normalizedImageUrl = imageUrl && imageUrl.trim() ? normalizeUrl(imageUrl) : '';
            const normalizedUrl = normalizedImageUrl || '';
            
            // Calculate blur based on distance from center
            // Max blur when section is half a viewport height away, no blur when centered
            const maxBlurDistance = containerHeight * 0.4; // Distance at which blur is maximum
            const maxBlur = 8; // Maximum blur in pixels
            const blurAmount = Math.min(maxBlur, (minDistance / maxBlurDistance) * maxBlur);
            
            // Apply blur to the image
            if (slideImage) {
              slideImage.style.filter = `blur(${blurAmount}px)`;
            }
            
            if (currentImageUrl !== normalizedUrl) {
              currentImageUrl = normalizedUrl;
              
              // Update background (pass section for custom colors)
              // Pass null if imageUrl is empty, otherwise pass the imageUrl
              updateBackground(imageUrl && imageUrl.trim() ? imageUrl : null, activeSection);
              
              const slideContainer = document.querySelector('.slide-container');
              const imageContainer = document.querySelector('.slide-image-container');
              
              // Use requestAnimationFrame to batch DOM updates and prevent flicker
              requestAnimationFrame(() => {
                if (imageUrl && imageUrl.trim()) {
                  // Show image container first
                  if (imageContainer) {
                    imageContainer.style.display = '';
                  }
                  
                  // Remove no-image class from container
                  if (slideContainer) {
                    slideContainer.classList.remove('no-image');
                  }
                  
                  // Fade out
                  slideImage.style.display = 'block';
                  slideImage.classList.add('fade-out');
                  
                  // Change image after fade starts
                  setTimeout(() => {
                    slideImage.src = imageUrl;
                    slideImage.classList.remove('fade-out');
                  }, 250);
                } else {
                  // No image, hide the image container
                  slideImage.style.display = 'none';
                  
                  // Add no-image class to container for CSS targeting
                  if (slideContainer) {
                    slideContainer.classList.add('no-image');
                  }
                  
                  if (imageContainer) {
                    imageContainer.style.display = 'none';
                  }
                }
              });
            }
          }
        }
        
        // Update on scroll with throttling
        let scrollTimeout;
        scrollContainer.addEventListener('scroll', function() {
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(updateImageOnScroll, 50);
        });
        
        // Also use requestAnimationFrame for smoother updates
        let rafRunning = false;
        function rafUpdate() {
          if (!rafRunning) return;
          updateImageOnScroll();
          requestAnimationFrame(rafUpdate);
        }
        
        // Initial update (synchronous, before starting RAF loop)
        updateImageOnScroll();
        
        // Mark initial load as complete after a short delay
        setTimeout(() => {
          initialLoadComplete = true;
          rafRunning = true;
          requestAnimationFrame(rafUpdate);
        }, 100);
      });
    </script>
  </body>
</html>